{"pages":[{"title":"","text":"","link":"/categories/index.html"}],"posts":[{"title":"mysql 语句练习50题","text":"表名和字段-1.学生表Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别-2.课程表Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号-3.教师表Teacher(t_id,t_name) –教师编号,教师姓名-4.成绩表Score(s_id,c_id,s_score) –学生编号,课程编号,分数 测试数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667--建表--学生表CREATE TABLE `Student`( `s_id` VARCHAR(20), `s_name` VARCHAR(20) NOT NULL DEFAULT '', `s_birth` VARCHAR(20) NOT NULL DEFAULT '', `s_sex` VARCHAR(10) NOT NULL DEFAULT '', PRIMARY KEY(`s_id`));--课程表CREATE TABLE `Course`( `c_id` VARCHAR(20), `c_name` VARCHAR(20) NOT NULL DEFAULT '', `t_id` VARCHAR(20) NOT NULL, PRIMARY KEY(`c_id`));--教师表CREATE TABLE `Teacher`( `t_id` VARCHAR(20), `t_name` VARCHAR(20) NOT NULL DEFAULT '', PRIMARY KEY(`t_id`));--成绩表CREATE TABLE `Score`( `s_id` VARCHAR(20), `c_id` VARCHAR(20), `s_score` INT(3), PRIMARY KEY(`s_id`,`c_id`));--插入学生表测试数据insert into Student values('01' , '赵雷' , '1990-01-01' , '男');insert into Student values('02' , '钱电' , '1990-12-21' , '男');insert into Student values('03' , '孙风' , '1990-05-20' , '男');insert into Student values('04' , '李云' , '1990-08-06' , '男');insert into Student values('05' , '周梅' , '1991-12-01' , '女');insert into Student values('06' , '吴兰' , '1992-03-01' , '女');insert into Student values('07' , '郑竹' , '1989-07-01' , '女');insert into Student values('08' , '王菊' , '1990-01-20' , '女');--课程表测试数据insert into Course values('01' , '语文' , '02');insert into Course values('02' , '数学' , '01');insert into Course values('03' , '英语' , '03');--教师表测试数据insert into Teacher values('01' , '张三');insert into Teacher values('02' , '李四');insert into Teacher values('03' , '王五');--成绩表测试数据insert into Score values('01' , '01' , 80);insert into Score values('01' , '02' , 90);insert into Score values('01' , '03' , 99);insert into Score values('02' , '01' , 70);insert into Score values('02' , '02' , 60);insert into Score values('02' , '03' , 80);insert into Score values('03' , '01' , 80);insert into Score values('03' , '02' , 80);insert into Score values('03' , '03' , 80);insert into Score values('04' , '01' , 50);insert into Score values('04' , '02' , 30);insert into Score values('04' , '03' , 20);insert into Score values('05' , '01' , 76);insert into Score values('05' , '02' , 87);insert into Score values('06' , '01' , 31);insert into Score values('06' , '03' , 34);insert into Score values('07' , '02' , 89);insert into Score values('07' , '03' , 98); 练习题和sql语句 1.查询下月过生日的学生 12select * from student where MONTH(DATE_FORMAT(NOW(),'%Y%m%d'))+1 =MONTH(s_birth)#后面的月和日要小写，前面的年大小写无所谓，否则：虽然结果不会错，但会报warning 2.查询本月过生日的学生 1select * from student where MONTH(DATE_FORMAT(NOW(),'%Y%m%d')) =MONTH(s_birth) 3.查询下周过生日的学生 1select * from student where WEEK(DATE_FORMAT(NOW(),'%Y%m%d'))+1 =WEEK(s_birth) 4.查询本周过生日的学生 12select * from student where WEEK(DATE_FORMAT(NOW(),'%Y%m%d'))=WEEK(s_birth)select * from student where YEARWEEK(s_birth)=YEARWEEK(DATE_FORMAT(NOW(),'%Y%m%d')) 5.查询各学生的年龄 – 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一 1234567891011select s_birth,(DATE_FORMAT(NOW(),'%Y')-DATE_FORMAT(s_birth,'%Y') - (case when DATE_FORMAT(NOW(),'%m%d')&gt;DATE_FORMAT(s_birth,'%m%d') then 0 else 1 end)) as age from student;#这里着重注意case...when...then.else...end的用法``` &gt;6.查询选修了全部课程的学生信息 ```sqlselect * from student where s_id in( select s_id from score GROUP BY s_id HAVING count(*)=(select count(*) from course))#GROUP BY真的很方便，以及HAVING的作用~ 7.检索至少选修两门课程的学生学号 123SELECT s_id,count(*) as sel FROM score GROUP BY s_id HAVING sel&gt;2#HAVING和WHERE的区别，以及count(*)的妙用 8.统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 12SELECT c_id, count(*)as total FROM score GROUP BY c_id HAVING total&gt;5 ORDER BY total DESC,c_id;#GROUP BY和升降序的用法 9.查询每门功成绩最好的前两名 – 牛逼的写法 12345SELECT c_id,s_id,s_score FROM score a WHERE(SELECT COUNT(1) FROM score b WHERE a.c_id=b.c_id and a.s_score&lt;=b.s_score)&lt;=2ORDER BY a.c_id;#这个写法太nb惹~，自己和自己比较进行排序，学习学习，注意小于等于号，这个有点绕 10.查询 不同课程 成绩相同 的学生的学生编号、课程编号、学生成绩 12SELECT DISTINCT b.s_id,b.c_id,b.s_score FROM score a,score b WHERE a.c_id!=b.c_id and a.s_score=b.s_score;#1、注意断句~ 2、相同表的笛卡尔积的妙用 11.查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩 12345678910SELECT a.*,b.s_score,b.c_id,c.c_name FROM student a LEFT JOIN score b on a.s_id = b.s_id LEFT JOIN course c on b.c_id = c.c_id where b.c_id = (SELECT c_id from course c,teacher d where c.t_id = d.t_id and d.t_name = \"张三\") and b.s_score in (SELECT MAX(s_score) from score where c_id=b.c_id)-- 查询“张三”老师的课程号-- SELECT c_id from course c,teacher d where c.t_id = d.t_id and d.t_name = \"张三\"-- 选择最大成绩-- SELECT MAX(s_score) from score where c_id=b.c_id) 12.求每门课程的学生人数 1SELECT c_id,COUNT(*) FROM score GROUP BY c_id 13.查询课程编号为01且课程成绩在80分以上的学生的学号和姓名； 12SELECT a.s_id,b.s_name FROM score a LEFT JOIN student b ON a.s_id=b.s_id WHERE a.s_score &gt;= 80 AND a.c_id='01'# LEFT JOIN 用以保全左边表格的信息 14.查询不及格的课程 1SELECT a.s_id,a.c_id,b.c_name,a.s_score FROM score a LEFT JOIN course b ON a.c_id = b.c_id WHERE a.s_score&lt;60 15.查询任何一门课程成绩在70分以上的姓名、课程名称和分数 1SELECT b.s_name,c.c_name,a.s_score FROM score a LEFT JOIN student b ON a.s_id = b.s_id LEFT JOIN course c ON a.c_id = c.c_id WHERE s_score&gt;70 16.查询所有学生的课程及分数情况 12345678SELECT a.s_id,a.s_name, SUM(case c.c_name when \"语文\" then b.s_score else 0 end)as '语文', SUM(case c.c_name when \"数学\" then b.s_score else 0 end)as '数学', SUM(case c.c_name when \"英语\" then b.s_score else 0 end)as '英语', SUM(b.s_score)as '总分' FROM student a LEFT JOIN score b ON a.s_id=b.s_id LEFT JOIN course c ON b.c_id=c.c_id GROUP BY a.s_id,a.s_name; 17.查询课程名称为”数学”，且分数低于60的学生姓名和分数 12SELECT a.s_name,b.s_score FROM student a JOIN score b ON a.s_id=b.s_id WHERE b.c_id=(SELECT c_id FROM course c WHERE c_name='数学')and b.s_score&lt;60; 18.查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩 1234SELECT a.s_id,a.s_name, ROUND(AVG(b.s_score),2) as avg_score FROM student a LEFT JOIN score b ON a.s_id=b.s_id GROUP BY a.s_id,a.s_name HAVING avg_score&gt;=85; 19.查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 12345SELECT a.c_id,a.c_name, ROUND(AVG(b.s_score),2) as avg_score FROM course a JOIN score b ON a.c_id=b.c_id GROUP BY a.c_id,a.c_name ORDER BY avg_score DESC,a.c_id; 20.查询1990年出生的学生名单 1SELECT s_id,s_name FROM student WHERE YEAR(s_birth)=1990; 21.查询同名同性学生名单，并统计同名人数 123SELECT a.s_name,a.s_sex,count(*) FROM student a JOIN student b ON a.s_id!=b.s_id AND a.s_name=b.s_name AND a.s_sex=b.s_sex GROUP BY a.s_name,a.s_sex; 22.查询名字中含有”风”字的学生信息 1SELECT * FROM student WHERE s_name LIKE '%风%'; 23.查询男生、女生人数 1SELECT s_sex,COUNT(s_sex) as '人数' FROM student GROUP BY s_sex; 24.查询出只有两门课程的全部学生的学号和姓名 123451)SELECT s_id,s_name FROM student WHERE s_id IN (SELECT s_id FROM score GROUP BY s_id HAVING COUNT(c_id)=2);2)SELECT s_id,s_name FROM student WHERE s_id IN (SELECT s_id FROM score WHERE COUNT(c_id)=2 GROUP BY s_id); 25.查询每门课程被选修的学生数 1SELECT c_id,COUNT(s_id) as s_num FROM score GROUP BY c_id; 26.统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比 1234567891011121314select distinct f.c_name,a.c_id,b.`85-100`,b.`百分比`,c.`70-85`,c.`百分比`,d.`60-70`,d.`百分比`,e.`0-60`,e.`百分比` from score a left join (select c_id,SUM(case when s_score &gt;85 and s_score &lt;=100 then 1 else 0 end) as `85-100`, ROUND(100*(SUM(case when s_score &gt;85 and s_score &lt;=100 then 1 else 0 end)/count(*)),2) as `百分比` from score GROUP BY c_id)b on a.c_id=b.c_id left join (select c_id,SUM(case when s_score &gt;70 and s_score &lt;=85 then 1 else 0 end) as `70-85`, ROUND(100*(SUM(case when s_score &gt;70 and s_score &lt;=85 then 1 else 0 end)/count(*)),2) as `百分比` from score GROUP BY c_id)c on a.c_id=c.c_id left join (select c_id,SUM(case when s_score &gt;60 and s_score &lt;=70 then 1 else 0 end) as `60-70`, ROUND(100*(SUM(case when s_score &gt;60 and s_score &lt;=70 then 1 else 0 end)/count(*)),2) as `百分比` from score GROUP BY c_id)d on a.c_id=d.c_id left join (select c_id,SUM(case when s_score &gt;=0 and s_score &lt;=60 then 1 else 0 end) as `0-60`, ROUND(100*(SUM(case when s_score &gt;=0 and s_score &lt;=60 then 1 else 0 end)/count(*)),2) as `百分比` from score GROUP BY c_id)e on a.c_id=e.c_id left join course f on a.c_id = f.c_id; 27.查询所有课程的成绩第2名到第3名的学生信息及该课程成绩 1234567891011121314151617181920select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@i:=@i+1 as 排名 from score a,(select @i:=0)s where a.c_id='01' ORDER BY a.s_score DESC )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3 UNION select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@j:=@j+1 as 排名 from score a,(select @j:=0)s where a.c_id='02' ORDER BY a.s_score DESC )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3 UNION select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@k:=@k+1 as 排名 from score a,(select @k:=0)s where a.c_id='03' ORDER BY a.s_score DESC )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3;","link":"/2020/10/07/50_mysql_try/"},{"title":"Best wishes to you","text":"Hello,终于等到你！欢迎来到我的私人博客，在这里，我主要记录一些学习心得，当然，也会记录日常十分有意义的事情。人生苦短，进一步有进一步的欢喜。 使用HEXO框架搭建博客搭建过程1、需要安装node.js(含node 和 npm)2、安装hexo(来自一名台湾小伙) 1npm install hexo-cli -g 3、初始化博客目录 1hexo init lihui91.github.io (必须是这种格式) 4、进入该目录 1cd lihui91.github.io 5、连续常规操作 123hexo clean (清除缓存)hexo g (generator)hexo s (server||start) 6、打开自己的浏览器，输入localhost:4000(默认是4000端口) 切换主题这里有许多现成的主题，美轮美奂：hexo主题 1、选一个自己中意的主题，然后下载到本地 1git clone https://github.com/iissnan/hexo-theme-next themes/next 2、配置主题：在根目录下的 _config.yml文件中，修改theme为自己的主题 1theme:next 3、重新一遍连续常规操作 123hexo clean (清除缓存)hexo g (generator)hexo s (server||start) 4、再次打开网站看看修改效果 远端部署部署到同性交友网站github1、创建github pages仓库(lihui91.github.io)2、安装hexo-deployer-git 1npm install hexo-deployer-git --save 3、配置Git打开配置文件 123deploy: type: git repo: https://github.com/xxx/xxxx.github.io.git(仓库SSH链接) 4、推送网站到仓库托管 1hexo -d (deploy-部署) 5、访问网站 随便找台有浏览器的电脑，输入lihui91.github.io 推送文章1、两种方式新建博文 1.在blog根目录下使用如下命令:hexo new article(article为文章名)2.直接新建 2、给文章打上标签打开标签功能： 1hexo new page tags 将tags/index.md头部内容修改为： 12type: \"tags\" comments:false 在文章头部打上标签 1234tags: - tag1 - tag2 - tag3 3、给文章添加分类打开分类功能： 1hexo new page categories 打开categories/index.md，进行修改： 12type: \"categories\" comments: false 在文章头部添加分类 1234categories: - 分类1 - 分类2 - 分类3 进一步完善自己的网站 一些可能会用到的链接hexo及icarus主题个性定制Hexo Icarus主题配置完全手册live2d 参考网址：hexo搭建个人网站博客完全教程","link":"/2020/06/29/BestWishes/"},{"title":"fav-pic","text":"Some pictures I enjoy. continue…","link":"/2020/06/30/fav-pic/"},{"title":"Git_Begin","text":"Git 基础知识安装编辑器和浏览器对于编辑器来说，每个人都有不同的偏好，你可以自由选择。可以选择功能丰富的IDE（集成开发环境），比如 PyCharm；也可以选择相对轻量的编辑器，比如 Atom 或 Sublime Text。浏览器建议使用 Firefox 或 Chrome。 使用命令行你需要使用命令行窗口来执行许多操作。你可以使用 Windows 下的 cmd.exe，或是 macOS 和 Linux 下的终端（Terminal）。下面我们执行一个最简单的 whoami 命令（即 Who Am I？）： 12$ whoamilihui 这个命令会打印出当前计算机用户的名称。其他常用的命令还有 cd 命令，用来切换目录（change directory）；mkdir 命令，用来创建目录（make directory）。在不同的操作系统上，执行某个操作的命令可能会有所不同。 我们先来为我们的程序创建一个文件夹： 12$ mkdir watchlist$ cd watchlist 对于 Windows（非 WSL） 用户，如果你对不同系统下终端命令的区别不熟悉，那么建议在使用 Git Bash（安装 Git for Windows 后附带的终端程序） 来代替系统自带的 cmd.exe 或 Powershell。Git Bash 支持一些在 Linux 或 macOS 下才能使用的命令（程序），比如 ls、cat、nano、ssh 等。 需要注意下列命令的区别： 在 cmd.exe 中使用 dir 命令替代 ls 命令，使用 type 命令替代 cat 命令 对于 nano 命令，你可以替换为其他已安装的编辑器命令，比如对于 VS Code，可以使用 code 命令。或者，你也可以直接使用编辑器的图形界面创建文件并编辑。 使用 GitGit 是一个流行的版本控制工具，我们可以用它来记录程序源码和文件的变动情况，或是在编程时进行多人协作，你可以把它看做一个优雅的代码变动备份工具。 如果你还不熟悉 Git 也没关系，有时间再去了解原理。现在要做的第一件事就是在你的电脑上安装 Git （可以执行 git --help 命令检查是否已经安装，没有提示“命令未找到（Command not found）”则表示已安装）。 安装后可以在命令行先使用使用下面的命令查看版本，没有报错则表示已正确安装： 12$ git --versiongit version 2.17.1 为了让 Git 知道你是谁，以便在提交代码到版本仓库的时候进行记录，使用下面的命令设置你的信息： 12$ git config --global user.name \"lihui\" # 替换成你的名字$ git config --global user.email \"lih7253@gmail.com\" # 替换成你的邮箱地址 现在为我们的项目文件夹创建一个 Git 仓库，这会在我们的项目根目录创建一个 .git 文件夹： 12$ git initInitialized empty Git repository in ~/watchlist/.git/ Git 默认会追踪项目文件夹（或者说代码仓库）里所有文件的变化，但是有些无关紧要的文件不需要记录变化，我们在项目根目录创建一个 .gitignore 文件，在文件中写入忽略文件的规则。因为文件内容比较简单，我们直接在命令行使用 nano 来创建： 1$ nano .gitignore 在 nano 编辑界面写入常见的可忽略文件规则： 1234*.pyc*~__pycache__.DS_Store 使用 Control + O 和 Enter 键保存，然后按下 Control + X 键退出。在后续章节，对于简单的文件，都会使用 nano 创建，这部分操作你也可以使用编辑器图形界面来完成。 将程序托管到 GitHub（可选）这一步是可选的，将程序托管到 GitHub、GitLab 或是 BitBucket 等平台上，可以更方便的备份、协作和部署。这些托管平台作为 Git 服务器，你可以为本地仓库创建远程仓库。 首先要注册一个 GitHub 账户，点击访问注册页面，根据指示完成注册流程。登录备用。 设置 SSH 密钥一般情况下，当推送本地改动到远程仓库时，需要输入用户名和密码。因为传输通常是通过 SSH 加密，所以可以通过设置 SSH 密钥来省去验证账号的步骤。 首先使用下面的命令检查是否已经创建了 SSH 密钥： 1$ cat ~/.ssh/id_rsa.pub 如果显示“No such file or directory”，就使用下面的命令生成 SSH 密钥对，否则复制输出的值备用： 1$ ssh-keygen 一路按下 Enter 采用默认值，最后会在用户根目录创建一个 .ssh 文件夹，其中包含两个文件，id_rsa 和 id_rsa.pub，前者是私钥，不能泄露出去，后者是公钥，用于认证身份，就是我们要保存到 GitHub 上的密钥值。再次使用前面提到的命令获得文件内容： 12$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3Nza...省略 N 个字符...3aph book@lihui 选中并复制输出的内容，访问 GitHub 的 SSH 设置页面（导航栏头像 - Settings - SSH and GPG keys），点击 New SSH key 按钮，将复制的内容粘贴到 Key 输入框里，再填一个标题，比如“My PC”，最后点击“Add SSH key”按钮保存。 创建远程仓库访问新建仓库页面（导航栏“+” - New repository），在“Repository name”处填写仓库名称，这里填“watchlist”即可，接着选择仓库类型（公开或私有）等选项，最后点击“Create repository”按钮创建仓库。 因为我们已经提前创建了本地仓库，所以需要指定仓库的远程仓库地址（如果还没有创建，则可以直接将远程仓库克隆到本地）： 1$ git remote add origin git@github.com:lihui91/watchlist.git # 注意更换地址中的用户名 这会为本地仓库关联一个名为“origin”的远程仓库，注意将仓库地址中的“lihui”换成你的 GitHub 用户名。","link":"/2020/06/29/Git-Begin/"},{"title":"搭建php环境","text":"如何搭建PHP环境PHP是世界上最好的语言，但这句话最早来自于PHP公司自己，有点王婆卖瓜，自卖自夸的味道，但一旦用到PHP，就会觉得”嗯，PHP真香！”。PHP广泛应用到网站服务端上，虽然现在很多崭新的语言如雨后春笋，但PHP仍然占据很重要的席位。 我搭建的服务端体系基于PHP+Apache+Mysql结构 Windows下PHP环境搭建 安装PHP 安装Apache 安装MySQL(可视化界面要安装navicat) 注：最好安装在根目录下，便于管理 配置Apache 打开conf文件夹，打开httpd.conf，进行路径修改Define SRVROOT “D:/Apache24”ServerRoot “${SRVROOT}”进行端口修改Listen 8080 Cmd(管理员权限下）Httpd -k -startNetstat -ano|fidstr “8080” 查看端口占用情况Tasklist|fidstr “****” 查看程序占用情况若端口被占用，再次进行端口修改 详细配置情况：windows下PHP环境的搭建搭建PHP开发环境（Apache+PHP+MySQL） 端口运行在Htdocs文件夹中新建phpinfo.php文件里面写入一些内容： 成功运行，显示php version详细信息 集成环境安装优点：省时省力，不费心神WAMPserver(好用，下载安装即可，操作比较无脑)","link":"/2020/06/28/create-php-env/"},{"title":"Cookie和Session","text":"Cookie和Session的联系和区别 cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。 session其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session其实是利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。 注：为这个用户创建的Cookie的名称是aspsessionid。这个Cookie的唯一目的就是为每一个用户提供不同的身份认证。 cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。 cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。 如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造，但是如果你能够获取某个登录用户的 sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性. 如果浏览器使用的是cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器。 两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。(1)cookie数据存放在客户的浏览器上，session数据放在服务器上(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中。 问：为什么第一次访问的时候，会没有cookie呢？？我不是先设置，再获取吗？答：使用Chrome的dev tools查看“网络” 客户端： 可以看到，浏览器（客户端）向服务器发出一次请求，发出请求的时候，在请求头信息中带上了各种参数，告诉服务器，我要接收什么样的文本（Accept）、什么编码格式（Accept-Encoding）、什么语言（Accept-Language）等等，当然，还把Cookie也传到了服务器（Cookie）。 服务器端： 第一步：setcookie(‘a’,’value’) 因为cookie是设置在客户端的，setcookie函数自己并不能设置cookie，它只能通过头信息的方式告诉浏览器说：兄弟，我要设置一个cookie，键为a，值为value，你在你那里帮我设置一下。你也可以理解为：”来，朕今天高兴，赏你一个小甜饼“。 第二步：$_COOKIE[‘a’]$_COOKIE[‘a’] 很简单，执行的操作就是在浏览器带过来的cookie字符串中搜索键为a的cookie，并返回它的值。 很明显，这个”键为a“的cookie不可能找到，因为客户端访问服务器的时候，这个cookie压根就不存在，而前面第一步设置cookie的头信息，也还没有返回给客户端（php要从上到下把语句执行完才会返回给客户端） 第三步：服务器返回信息 其中，返回的头信息中带有”Set-Cookie a=value“，浏览器收到这个头信息，把cookie存放到电脑的某个文件中，对于不同浏览器cookie的存放位置貌似不同，这个不在本文的范围。 刷新浏览器，再次访问服务器的时候，同样，也会把很多头信息带给服务器，只不过这次带过去的cookie中，就多了一个a=value了。$_COOKIE[‘a’]自然就能从cookie字符串中找到这个键为a的cookie的值。","link":"/2020/06/30/cookie-session/"},{"title":"discuz","text":"discuz年代久远，是基于php，mysql,apache的一个开源论坛项目，不过时至今日，该开源项目仍然能适应构建很多基础应用网站，可以将其理解为一个比较强大的php模板。在配置discuz项目的过程中，我遇到了很多的坑，不过没及时在掉坑的时候总结，现在好像对这些坑的记忆比较模糊了，所以还是要及时记录啊。Those who don’t remenber the past are comdemed to repeat it! 关于字符编码 字符编码有多种格式，常用的有utf-8（万国码），和gbk（中国编码），需要注意的地方是代码的编码分为代码指定编码和 页面内置编码两块，我用的discuz开源模板代码有gbk模式的，为了保持一致，所以选择将php.ini里的编码格式改为gbk，同时要利用notepad++或者vs code(auto guess encoding)等编辑器将代码转化为gbk格式，当这两者保持一致了，页面才不会出现乱码。 关于php版本 discuz是很有年代感的东西，所以php版本不能用最近的，我用的是php5.6 关于数据库连接 开始在阿里云服务器部署的时候用的phpStudy，数据库总是连接不了，很是奇怪，百思不得其解，只好在服务器安装wamp，这样就好了。但这两个集成环境配置都是一样的，可能原因是phpStudy的数据库不能自适应编码格式，而wamp能够自适应这些编码，所以数据库连接很简单顺利，以后还是不要为这些环境配置而烦恼了，力气要花在刀刃上。 关于外网访问80端口网站已经部署到服务器，可是外网输入该服务器ip地址却无法访问怎么办 1、在服务器控制台，选择安全组，配置规则，配置好80端口访问2、在Apache的httpd-vgost.conf里面进行配置需要将Require localhost改为Require all granted，即所有的终端都可通过互联网访问 &lt;VirtualHost *:80&gt; ServerName localhost ServerAlias localhost DocumentRoot \"${INSTALL_DIR}/www\" &lt;Directory \"${INSTALL_DIR}/www/\"&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; 其他其实过程中的问题远远不止这些，不过要么忘了，要么太智障，暂时先记录这么多吧，以后遇到一个问题一定要记得及时记录，这样记忆才会更加深刻一些。 待续…","link":"/2020/07/08/discuz/"},{"title":"web 前端 | html篇","text":"原文地址首先这份合集源于网络， 原文地址 ，此处只是做记笔记的作用 页面导入样式时，使用 link 和 @import 有什么区别。1、从属关系区别。@import 只能导入样式表，link 还可以定义 RSS、rel 连接属性、引入网站图标等；2、加载顺序区别；加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载；3、兼容性区别； 常见浏览器内核 内核 Trident：IE 浏览器内核；Gecko：Firefox 浏览器内核；Presto：Opera 浏览器内核；Webkit：Safari 浏览器内核；Blink：谷歌浏览器内核，属于 Webkit 的一个分支，与 Opera 一起在研发； 浏览器 IE：Trident，IE 内核；Chrome：以前是 Webkit，现在是 Blink 内核；Firefox：Gecko 内核；Safari：Webkit 内核；Opera：一起是 Presto，现在是 Blink 内核；360、猎豹浏览器内核：IE + Blink 双内核；搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；百度浏览器、世界之窗内核：IE 内核；2345 浏览器：以前是 IE 内核，现在是 IE + Blink 双内核；UC 浏览器内核：Webkit + Trident； 浏览器的渲染原理 1、首先解析收到的文档，根据文档定义构建一颗 DOM 树，DOM 树是由 DOM 元素及属性节点组成的；2、然后对 CSS 进行解析，生成 CSSOM 规则树；3、根据 DOM 树和 CSSOM 规则树构建 Render Tree。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 对象相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。4、当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。5、布局阶段结束后是绘制阶段，比那里渲染树并调用对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。 为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。","link":"/2021/03/12/web%E5%89%8D%E7%AB%AF%E6%B1%87%E6%80%BB/"},{"title":"matlab_begin","text":"matlab之左除右除 运算符 名称 说明 /（向右倒称为右除） 右除 AB=C A=C/B \\（向左倒称为左除） 左除 AB=C B=A\\C B\\A 就是对应线性方程B*X=A 的解。 在斜线上面的是被除数 \\ 左除 / 右除 A\\B=inv(A)*B （A左除B=A的逆乘以B） &gt;&gt; 3\\5 ans = 1.66673的逆=三分之一，再乘以5. A/B=A*(inv(B)) (A右除B等于A乘以B的逆） &gt;&gt; 3/5 ans = 0.6000 matlab之冒号字符 格式 目的 A(:,j) 是A的第j列 A(i,:) 是A的第j行 A(:,:) 是等效的二维数组；对于矩阵，这与A相同 A(j:k) 是A（j），A（j + 1），…，A（k） A(:,j:k) 是 A(:,j)， A(:,j+1)，…，A(:,k) A(:,:,k) 是三维数组A的第k页 A(i,j,k,:) 是四维数组A中的矢量；矢量包括A（i，j，k，1），A（i，j，k，2），A（i,j，k，3）等 A(:) 是 A 的所有要素，被视为单列；在赋值语句的左侧，A（:) 填充A，保留以前的形状；在这种情况下，右侧必须包含与A相同数量的元素。 例 A = [1 2 3 4; 4 5 6 7; 7 8 9 10] A(:,2) % second column of A A(:,2:3) % second and third column of A A(2:3,2:3) % second and third rows and second and third columns 结果 A = 1 2 3 4 4 5 6 7 7 8 9 10 ans = 2 5 8 ans = 2 3 5 6 8 9 ans = 5 6 8 9","link":"/2020/07/06/matlab-begin/"},{"title":"已经不会了的排序orz","text":"快速排序 时间复杂度O(logn)。空间复杂度是O(n)。 主要是要找出标杆值（中间值），默认最后一个值为标杆值，然后比它小的放左边，比他大的放右边，然后交换最后一位。就得到标杆值在中间的下标。 树，从上往下排序 不稳定算法 vector MySort(vector& arr) { // 快排 if(arr.size()","link":"/2021/03/10/nowcoder_sort/"},{"title":"数据结构和算法面试常考题","text":"1、请说一说你理解的Stack Overflow，并举个简单例子导致栈溢出。栈溢出概念：栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身申请的字节数，因而导致栈中与其相邻的变量的值被改变。栈溢出的原因：1、局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈当中的。解决这个问题的办法有两个，一是增大栈空间，二是改用动态分配，使用堆而不是栈。2、递归调用次数太多。递归函数在运行时会进行压栈操作，当压栈次数太多时，也会导致堆栈溢出。3、指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等。 栈溢出例子： 123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(int argc, char* argv[]){ char buf[256]; strcpy_s(buf, argv[1]); printf(&quot;input:%s\\n&quot;, buf); return 0;} 上述代码 strcpy_s(buf, argv[1]); 发生了缓冲区溢出错误，因为原缓冲区内容是用户输入的。 2、请你说一下堆和栈的区别，以及为什么栈要快？ 堆和栈的区别：堆是由低地址向高地址扩展；栈是由高地址向低地址扩展。堆中的内存需要手动申请和手动释放，栈中内存时由OS自动申请和自动释放，存放着参数，局部变量等内存。堆中频繁调用malloc和free，会产生内存碎片，降低程序效率；而战由于其先进后出的特性，不会产生内存碎片堆的分配效率较低，而栈的分配效率较高。 栈的效率高的原因：栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一系列内存分配、合并内存和释放内存的算法，因此效率较低。 3、请你说一说小根堆特点？堆是一棵完全二叉树(如果一共有h层,那么1~h-1层均满，在h层可能会连续缺失若干个右叶子)。1)小根堆若根节点存在左子女则根节点的值小于左子女的值;若根节点存在右子女则根节点的值小于右子女的值。2)大根堆若根节点存在左子女则根节点的值大于左子女的值;若根节点存在右子女则根节点的值大于右子女的值。 4、手写代码，两个栈实现一个队列。参考代码： 12345678910111213141516171819202122232425class Solution{public:void push(int node){ stack1.push(node);}int pop(){if(stack2.size()!=O){ int tmp = stack2.top(); tack2.pop(); return tmp;} else{ while(stack1.size()!=0) { int tmp = stack1.top(); stack1.pop(); stack2.push(tmp);} return pop(); }}private:stack&lt;int&gt; stack1;stack&lt;int&gt; stack2;}; 5、请你来说一下堆和栈的区别.1)申请方式:栈由系统自动分配和管理,堆由程序员手动分配和管理。2)效率:栈由系统分配，速度快,不会有内存碎片。堆由程序员分配,速度较慢，可能由于操作不当产生内存碎片。3)扩展方向栈从高地址向低地址进行扩展,堆由低地址向高地址进行扩展。4)程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间,函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。 6、请问快排的时间复杂度最差是多少?什么时候时间最差?O(N^2)，元素本来倒序排列用时最多。 7、请问稳定排序有几种？基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序 8、请你来手写一下快排的代码。参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6int partition(int arr[], int low, int high){ int key; key = arr[low]; while(low&lt;high){ while(low &lt;high &amp;&amp; arr[high]&gt;= key ) high--; if(low&lt;high) arr[low++] = arr[high]; while( low&lt;high &amp;&amp; arr[low]&lt;=key ) low++; if(low&lt;high) arr[high--] = arr[low]; } arr[low] = key; return low;}void quick_sort(int arr[], int start, int end){ int pos; if (start&lt;end){ pos = partition(arr, start, end); quick_sort(arr,start,pos-1); quick_sort(arr,pos+1,end); } return;}int main(void){ int i; int arr[N]={32,12,7, 78, 23,45}; printf(&quot;排序前 \\n&quot;); for(i=0;i&lt;N;i++) printf(&quot;%d\\t&quot;,arr[i]); quick_sort(arr,0,N-1); printf(&quot;\\n 排序后 \\n&quot;); for(i=0; i&lt;N; i++) printf(&quot;%d\\t&quot;, arr[i]); printf (&quot;\\n&quot;); system(&quot;pause&quot;); return 0;} 9、请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时,还可以使用什么不同的方法求第k大的元素？首先使用快速排序算法将数组按照从大到小排序,然后取第k个,其时间复杂度最快为0(nlogn)使用堆排序，建立最大堆,然后调整堆,知道获得第k个元素,其时间复杂度为O(n+klogn)首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想,线性从大到小扫描过程中,前面有k-1个数则为第k大的数利用快排思想，从数组中随机选择一个数i,然后将数组分成两部分Dl,Dr，Dl的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素;如果Dr元素个数大于k,那么继续求Dr中第k大的元素当有相同元素的时候：首先利用哈希表统计数组中个元素出现的次数,然后利用计数排序的思想，线性从大到小扫描过程中,前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n) 10、请你来介绍一下各种排序算法及时间复杂度 插入排序:对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素,插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位;如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。 希尔排序:先将整个待排序记录分割成若干子序列,然后分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割,而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1. 归并排序:该算法采用分治法;对于包含m个元素的待排序序列,将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列;然后再两两归并,直到得到1个长度为m的有序序列。 冒泡排序:对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置;然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次,完成排序。 快速排序:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序,整个排序过程可以递归进行，以此达到整个数据变成有序序列。 选择排序:每次循环，选择当前无序数组中最小的那个元素,然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。 堆排序:堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆(升序)/最小堆(降序)，然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。各个排序算法的时空复杂度以及稳定性如下表：","link":"/2021/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"捡拾前端知识点1","text":"html 标签的一些共有的属性有哪些? class|id|style|title|dir|langhtml5新增: draggable|dragzone|hidden|spellcheck参考链接 html 的新特性，除了语义化标签还有什么? 语义化：有些html标签都有自己的语义及使用情况，这就叫语义化新增特性：新增表单属性、新的DOCTYPE声明、完全支持CSS3、新增video和audio标签、本地存储、语义化标签、地理位置获取参考链接 给出一个布局，计算宽和高 CSS3使用calc()计算 continue…","link":"/2021/03/01/%E6%8D%A1%E6%8B%BE%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9_1/"},{"title":"记录字节一面","text":"今天3月16，下午进行了字节的前端实习生一面，时长70分钟，运气好碰到了同济的老学长，很亲切，面试体验良好。不过忘记录屏了，趁着现在还能记起来点，赶紧记录一下，能记录多少就记录多少吧~寒假快结尾的时候抱着尝试一下的态度投了字节的实习生岗位，约好了在今天面试。我想好好锻炼下自己，如果梦想成真的话，下半年就会很充实，想想就很快乐呢~然而必须认识的一个现实是我真的好菜，比起很多大佬来说毫无卖点。这两周在众多课程的间隙，我得复习大量的前端后端、计算机基础、操作系统、算法知识（看到很多面经里说前端不止问前端。。。），参考大量的面经，以及刷各种类型的题。怪我之前欠的账太多了，现在只能踉踉跄跄。 话不多说，且步入正题，开始记录： 请你进行一下简单的自我介绍吧 :)我看你有搭建自己的个人博客，你能详细描述下它的技术栈吗？既然你是用已有的hexo搭建的博客，那么你有没有在此基础上进行一些改良？搭建博客过程中课程碰到一些困难我看了你的创新项目《小兵种武器维修检索平台》，请描述一下它的技术栈谈谈你项目中碰到的困难好，我们步入正题，请谈谈javascript基本的数据类型对this有了解吗？请详述一下对箭头函数(lambda表达式)有了解吗？请详述一下请你描述一下浏览器中输入url到获得页面的详细过程谈一谈三次握手的过程谈一谈四次挥手的过程对JS的循环机制了解吗？请描述一下谈谈异步操作谈谈微任务和宏任务的区别知道进程和线程的区别吗？OK，请谈下浏览器的缓存机制吧你刚才谈到了协商缓存，那你对在强缓存可以使用的情况下，服务端给客户端发送的报文有哪些参数吗？（大概意思是这样，描述的不是很准确orz） 以上就是面试官主要问到的一些问题了，面试的是前端，结果html和CSS这些都没怎么问，主要问的还是JS，可能那个岗位主要还是用JS处理问题，不管怎样，以后还是把JS好好拎一拎吧。其他的还涉及到很多计算机网络、操作系统方面的知识，这些比较偏底层，而且很多还没开始学，我只是把知道的都讲了出来。最后的大头还是白板代码部分，我的致命缺陷，要知道，平时写代码可都是有了思路就去查有没有现成的，有现成的直接拿来用，或者改改就行了。当时选老师也是偷懒没选SJ老师，导致现在就是比较后悔。出来混，早晚都要还的呀~不过还好，这几个代码题都比较简单，可能是学长看在我是小学弟的份上没刁难我:kissing_closed_eyes: 白板代码合并两个已经排好序的数组给你一个链表，判断它是否有环给你一个字符串，请给出它的最长回文子串代码部分，思路都有，由于面的前端嘛，最好是用JS来写，不过我常用的还是C++，所以用C++写的。主要问了算法思想以及时空复杂度。总结就是，经此一役，我发现了我就是个只会说不会干的水货，所以之后需要在实战能力方面进一步增强。 反问环节你有什么要问我的吗？1、如果我真的有幸能够得到实习机会，请问我现在需要进一步学习哪些知识？答：前端三件套肯定是必须的，计算机基础和算法也都要很熟悉，特别要把JS好好练练，平时写代码可以考虑多用用JS。2、您对我的评价？答：总体上基础知识掌握的挺扎实的，代码方面能看出来你有刷过题，但是还是得加强训练。 总结大体上就上面这些内容吧，一面嘛，问的东西都偏基础，比较简单，代码题，实话实说，真的很简单，leetcode上任何一道简单的题可能都要比这些题难，但是我还是写的好慢，平时写代码可真得尝试脱离检索了。面试给我的感觉是，前期比较紧张，但是没过多久就习惯了，面试过程总体还是很愉快的。然后这个岗位虽然说是前端，但是还是涉及到很多后端思想的，问了很多JS方面的东西，应该是要用JS写各种逻辑部件吧。不论后续如何，还是得加强修炼，任重道远，认识到自己很菜可不是一件坏事~","link":"/2021/03/16/%E5%87%89%E5%87%89%E7%9A%84%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E4%B8%80%E9%9D%A2/"},{"title":"wish-to-friends","text":"祝福一转眼，曾经的同学一个个的都毕业了，看着朋友圈的大家都去了理想的高校继续深造或者跃入人海，甚是羡慕，同时也为你们送去衷心的祝福。 跃入人海，各有风雨灿烂","link":"/2020/06/30/wish-to-friends/"},{"title":"关于UNIX时间戳的坑","text":"今天陷入到UNIX时间戳的坑了，久久无法自拔，woc~ 我在publish_deal.php中传了一个发布时间到数据库 12//获取当前的发帖时间$pub_time = time(); 然后在index.php中以时间为条件取数据 $sql = \"select count(*) as cnt_php_tdy from `publish` where `module_id`='web技术' and `area`='PHP真香' and DAYOFMONTH(pub_time)=DAYOFMONTH(now()) and MONTH(pub_time)=MONTH(now()) and year(pub_time)=year(now())\"; $result = $conn-&gt;query($sql); $row = $result-&gt;fetch_assoc(); $cnt_php_tdy = $row['cnt_php_tdy']; 最后取出来的数目总是0，f**k 纠结半天后终于发现错误所在time()函数取得的是当前系统的UNIX时间戳（像这样：1593502233），并不是正常的年月日那种形式 需要在sql语句中将UNIX时间戳解析，像这样： $sql = \"select count(*) as cnt_php_tdy from `publish` where `module_id`='web技术' and `area`='PHP真香' and DAYOFMONTH(FROM_UNIXTIME(pub_time))=DAYOFMONTH(now()) and MONTH(FROM_UNIXTIME(pub_time))=MONTH(now()) and year(FROM_UNIXTIME(pub_time))=year(now())\"; $result = $conn-&gt;query($sql); $row = $result-&gt;fetch_assoc(); $cnt_php_tdy = $row['cnt_php_tdy']; 这下终于能取出正确的数据了 ：) 有关项目：web大作业——mind worse share论坛","link":"/2020/06/30/timemark/"}],"tags":[{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"好图","slug":"好图","link":"/tags/%E5%A5%BD%E5%9B%BE/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"服务端","slug":"服务端","link":"/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"踩坑日常","slug":"踩坑日常","link":"/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E5%B8%B8/"},{"name":"matlab","slug":"matlab","link":"/tags/matlab/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"心得","slug":"心得","link":"/tags/%E5%BF%83%E5%BE%97/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"diary","slug":"diary","link":"/categories/diary/"}]}